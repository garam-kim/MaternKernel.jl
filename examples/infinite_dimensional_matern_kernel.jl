using FrankWolfe
using Plots
using LinearAlgebra
using Random

include(joinpath(dirname(pathof(FrankWolfe)), "../examples/plot_utils.jl"))



# ## Infinite-dimensional kernel herding
# We focus on a specific kernel studied in ([Tsuji et al.](https://proceedings.mlr.press/v162/tsuji22a/tsuji22a.pdf)), that has an infinite dimensional feature space.
# Let $\mathcal{Y} = [-1, 1]$ and
# ```math
# \mathcal{H}:= \left\lbrace f \colon \mathcal{Y} \to \mathbb{R} \mid f = \sum_{i=1}^{\infty}c_i k(\cdot,y_i) \text{ where } c_i \in \mathbb{R}, y_i \in \mathcal{Y} \right\rbrace.
# ```
# [Kanagawa et al.](https://arxiv.org/pdf/1807.02582.pdf) showed that $\mathcal{H}$ is a Reproducing Kernel Hilbert Space (RKHS) generated by the Mat√©rn kernel
# ```math
# k(y, z) = \frac{2^{1-\nu}}{\Gamma (\nu)}\Big( \sqrt{2\nu} \frac{\lVert y-z \rVert_2}{\rho} \Big)^\nu B_{\nu} \Big( \sqrt{2\nu} \frac{\lVert y-z \rVert_2}{\rho} \Big),
# ```
# where $y, z \in \mathcal{Y}$ and $B_\nu$ is the modified Bessel function of the second kind and $\rho$ and $\nu$ are positive parameters.



# ### Set-up

max_iterations = 1000
max_iterations_lmo = 10^3
lmo = MarginalPolytope(max_iterations_lmo)

# ### Uniform distribution
# First, we consider the uniform distribution $\rho = \frac{1}{2}$.

mu = UniformMeanElement()
iterate = KernelHerdingIterate([1.0], [0.0])
gradient = KernelHerdingGradient(iterate, mu)
f, grad = create_loss_function_gradient(mu)

# We then run the experiments.

FW_OL = FrankWolfe.frank_wolfe(f, grad, lmo, iterate, line_search=FrankWolfe.Agnostic(), verbose=true, gradient=gradient, memory_mode=FrankWolfe.OutplaceEmphasis(), max_iteration=max_iterations, trajectory=true)
FW_SS = FrankWolfe.frank_wolfe(f, grad, lmo, iterate, line_search=FrankWolfe.Shortstep(1), verbose=true, gradient=gradient, memory_mode=FrankWolfe.OutplaceEmphasis(), max_iteration=max_iterations, trajectory=true)
BPFW_SS = FrankWolfe.blended_pairwise_conditional_gradient(f, grad, lmo, iterate, line_search=FrankWolfe.Shortstep(1), verbose=true, gradient=gradient, memory_mode=FrankWolfe.OutplaceEmphasis(), max_iteration=max_iterations, trajectory=true)

# We plot the results.

data = [FW_OL[end], FW_SS[end], BPFW_SS[end - 1]]
labels = ["FW-OL", "FW-SS", "BPFW-SS"]
plot_trajectories(data, labels, xscalelog=true)
